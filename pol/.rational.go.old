package pol_type

import "strconv"
import "strings"
import "fmt"

func (r Pol_Rational) GetType() Type_identifier {
    return r.id
}

func (r Pol_Rational) String() string {
    fmt.Println(r.numerator," ",r.denomiator, " ",r.numerator/r.denomiator)
    return string(r.numerator/r.denomiator)
}

func (r Pol_Rational) Convert(c Pol_Type) Pol_Type{
    if c.GetType() == STRING {
        fmt.Println("CONVERTING",r.String())
        return NewString(r.String())
    }

    return NewNothing()
}

type Pol_Rational struct {
    id Type_identifier
    numerator uint
    denomiator uint
    negative bool
}

func NewRational(constant string) Pol_Rational {
    i, _ := strconv.ParseFloat(constant,64)
    d := (len(constant) - (strings.IndexRune(constant,'.') + 1)) * 10
    n := i * float64(d)
    g := gcd(uint(n),uint(d))
    return Pol_Rational{RATIONAL,uint(n)/g,uint(d)/g,false}
}

func lcm(u uint, v uint) uint {
    return u*v / gcd(u,v)
}

// Binary GCD
// https://en.wikipedia.org/wiki/Binary_GCD_algorithm
func gcd(u uint, v uint) uint {
    if u == v {
        return u
    }

    if u == 0 {
        return v
    }

    if v == 0 {
        return u
    }

    if u % 2 == 0 {  //U is even
        if v % 2 != 0 { //V is odd
            return gcd(u >> 1,v)
        }else{ // U and V are even
            return gcd(u >> 1, v >> 1) << 1
        }
    }

    if  v % 2 != 0 { //U is odd V is odd
        return gcd(u, v >> 1)
    }

    if u > v {
        return gcd((u - v) >> 1,v)
    }
    return gcd((v - u) >> 1, u)
}

func (r Pol_Rational) Hash() uint{
    return 37 * r.numerator + 13 * r.denomiator
}

func (r1 Pol_Rational) Add(r2 Pol_Type) Pol_Type {

//    denom := lcm(r1.denomiator, r2.denomiator)
//    num1 := denom/r1.denomiator
//    num2 := denom/r2.denomiator
//    (r1.numerator * num1) + (r2.numerator * num2)
    return NewRational("1.0")
}

func (r1 Pol_Rational) Subtract(r2 Pol_Type) Pol_Type {
    fmt.Println("Operator binary subtract '-' is undefined for type string")
    return NewRational("1.0")
}

func (r1 Pol_Rational) Multiply(r2 Pol_Type) Pol_Type {
    fmt.Println("Operator binary multiply '*' is undefined for type rational")
    return NewRational("1.0")
}

func (r1 Pol_Rational) Divide(r2 Pol_Type) Pol_Type{
    fmt.Println("Operator binary divide '/' is undefined for type string")
    return NewRational("1.0")
}

func (r1 Pol_Rational) Exponent(r2 Pol_Type) Pol_Type{
    fmt.Println("Operator binary exponent '^' is undefined for type string")
    return NewRational("1.0")
}

func (r1 Pol_Rational) Mod (r2 Pol_Type) Pol_Type {
    fmt.Println("Operator binary mod '%' is undefined for type string")
    return NewRational("1.0")
}

func (r1 Pol_Rational) Equals(r2 Pol_Type) Pol_Bool {
    return NewBool(r1 == r2)
}

func (r1 Pol_Rational) NotEquals(r2 Pol_Type) Pol_Bool {
    return (r1.Equals(r2)).Not()
}

func (r1 Pol_Rational) Less(r2 Pol_Type) Pol_Bool {
    fmt.Println("Operator binary less '<' is undefined for type string")
    return NewBool(true)
}

func (r1 Pol_Rational) Greater(r2 Pol_Type) Pol_Bool {
    fmt.Println("Operator binary greater '>' is undefined for type string")
    return NewBool(true)
}

func (r1 Pol_Rational) LessEquals(r2 Pol_Type) Pol_Bool {
    fmt.Println("Operator binary lessEquals '<=' is undefined for type string")
    return NewBool(true)
}

func (r1 Pol_Rational) GreaterEquals(r2 Pol_Type) Pol_Bool {
    fmt.Println("Operator binary greaterEquals '>=' is undefined for type string")
    return NewBool(true)
}

func (r1 Pol_Rational) Not() Pol_Bool {
    fmt.Println("Operator unary not '!' is undefined for type string")
    return NewBool(true)

}

func (r1 Pol_Rational) And(Pol_Type) Pol_Bool{
    return NewBool(true)
}

func (r1 Pol_Rational) Or(Pol_Type) Pol_Bool{
    return NewBool(true)
}
